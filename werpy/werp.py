# SPDX-FileCopyrightText: 2023 Analytics in Motion <https://www.analyticsinmotion.com>
# SPDX-License-Identifier: BSD-3-Clause

"""
This module provides a function to calculate a weighted Word Error Rate for the entire reference and hypothesis 
texts. It allows varying weights to be assigned to the insertion, deletion and substitution errors.

This module defines the following function:
    - werp(reference, hypothesis)
"""

import numpy as np
from .errorhandler import error_handler


def werp(
    reference,
    hypothesis,
    insertions_weight=1,
    deletions_weight=1,
    substitutions_weight=1,
):
    """
    This function calculates a weighted Word Error Rate for the entire reference and hypothesis texts. It allows the
    insertion, deletion and substitution errors to be penalized or weighted at different rates.

    Parameters
    ----------
    reference : str, list or numpy array
        The ground truth transcription of a recorded speech or the expected output of a live speech.
    hypothesis : str, list or numpy array
        The text generated by a speech-to-text algorithm/system which will be compared to the reference text.
    insertions_weight: int or float, optional
        The weight multiplier for an insertion error
    deletions_weight: int or float, optional
        The weight multiplier for a deletion error
    substitutions_weight: int or float, optional
        The weight multiplier for a substitution error

    Raises
    ------
    ValueError
        if the two input parameters do not contain the same amount of elements.
    AttributeError
        if input text is not a string, list or np.ndarray data type.
    ZeroDivisionError
        if input in reference is blank or both reference and hypothesis are empty.

    Returns
    -------
    float
        This function will return a single weighted Word Error Rate.

    Examples
    --------
    >>> ref = ['it was beautiful and sunny today']
    >>> hyp = ['it was a beautiful and sunny day']

    >>> werp_example_1 = werp(ref, hyp)
    >>> print(werp_example_1)
    0.3333333333333333

    >>> werp_example_2 = werp(ref, hyp, insertions_weight=1, deletions_weight=1, substitutions_weight=1)
    >>> print(werp_example_2)
    0.3333333333333333

    >>> werp_example_3 = werp(ref, hyp, insertions_weight=0.5, deletions_weight=0.5, substitutions_weight=1)
    >>> print(werp_example_3)
    0.25

    >>> werp_example_4 = werp(ref, hyp, 0.5, 0.5, 1)
    >>> print(werp_example_4)
    0.25
    """
    try:
        word_error_rate_breakdown = error_handler(reference, hypothesis)
    except (ValueError, AttributeError, ZeroDivisionError) as err:
        print(f"{type(err).__name__}: {str(err)}")
        return None

    b = word_error_rate_breakdown

    # Unwrap 0-D container
    if isinstance(b, np.ndarray) and b.ndim == 0:
        b = b.item()

    if isinstance(b, np.ndarray):
        if b.ndim == 2:
            # True 2-D numeric batch
            t = b.T
            weighted_insertions = np.sum(t[3]) * insertions_weight
            weighted_deletions = np.sum(t[4]) * deletions_weight
            weighted_substitutions = np.sum(t[5]) * substitutions_weight
            m = np.sum(t[2])

        elif b.ndim == 1:
            # Could be either:
            # (a) single example row vector, or
            # (b) object array of per-example vectors
            first = b[0] if b.size else None

            if isinstance(first, (np.ndarray, list, tuple)):
                # Batch stored as 1-D object array of per-example vectors (ragged fields exist)
                total_insertions = 0.0
                total_deletions = 0.0
                total_substitutions = 0.0
                total_m = 0.0
                for r in b:
                    rr = r.tolist() if isinstance(r, np.ndarray) else r
                    total_insertions += float(rr[3])
                    total_deletions += float(rr[4])
                    total_substitutions += float(rr[5])
                    total_m += float(rr[2])
                weighted_insertions = total_insertions * insertions_weight
                weighted_deletions = total_deletions * deletions_weight
                weighted_substitutions = total_substitutions * substitutions_weight
                m = total_m
            else:
                # Single example vector
                weighted_insertions = b[3] * insertions_weight
                weighted_deletions = b[4] * deletions_weight
                weighted_substitutions = b[5] * substitutions_weight
                m = b[2]

        else:
            raise ValueError(f"Unexpected metrics output ndim: {b.ndim}")

    else:
        # Non-numpy fallback (assume [wer, ld, m, ...])
        weighted_insertions = b[3] * insertions_weight
        weighted_deletions = b[4] * deletions_weight
        weighted_substitutions = b[5] * substitutions_weight
        m = b[2]

    weighted_errors = weighted_insertions + weighted_deletions + weighted_substitutions
    werp_result = float(weighted_errors / m) if m else 0.0
    return werp_result
