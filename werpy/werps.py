# SPDX-FileCopyrightText: 2023 Analytics in Motion <https://www.analyticsinmotion.com>
# SPDX-License-Identifier: BSD-3-Clause

"""
This module provides a function for calculating a list of weighted Word Error Rate for each of the reference and
hypothesis texts. It allows varying weights to be assigned to the insertion, deletion and substitution errors.

This module defines the following function:
    - werps(reference, hypothesis)
"""

import numpy as np
from .errorhandler import error_handler


def werps(
    reference,
    hypothesis,
    insertions_weight=1,
    deletions_weight=1,
    substitutions_weight=1,
):
    """
    This function calculates a list of weighted Word Error Rates for each of the reference and hypothesis texts. It
    allows the insertion, deletion and substitution errors to be penalized or weighted at different rates.

    Parameters
    ----------
    reference : str, list or numpy array
        The ground truth transcription of a recorded speech or the expected output of a live speech.
    hypothesis : str, list or numpy array
        The text generated by a speech-to-text algorithm/system which will be compared to the reference text.
    insertions_weight: int or float, optional
        The weight multiplier for an insertion error
    deletions_weight: int or float, optional
        The weight multiplier for a deletion error
    substitutions_weight: int or float, optional
        The weight multiplier for a substitution error

    Raises
    ------
    ValueError
        if the two input parameters do not contain the same amount of elements.
    AttributeError
        if input text is not a string, list or np.ndarray data type.
    ZeroDivisionError
        if input in reference is blank or both reference and hypothesis are empty.

    Returns
    -------
    float or list
        This function will return either a single weighted Word Error Rate (if the input is a pair of strings) or a
        list of weighted Word Error Rates (if the input is a pair of lists) for each of the reference and hypothesis
        texts.

    Examples
    --------
    >>> ref = ['it blocked sight lines of central park', 'her father was an alderman in the city government']
    >>> hyp = ['it blocked sightlines of central park', 'our father was an elder man in the city government']

    >>> werps_example_1 = werps(ref, hyp)
    >>> print(werps_example_1)
    [0.2857142857142857, 0.3333333333333333]

    >>> werps_example_2 = werps(ref, hyp, insertions_weight = 0.5, deletions_weight = 0.5, substitutions_weight = 1)
    >>> print(werps_example_2)
    [0.21428571428571427, 0.2777777777777778]
    """
    try:
        word_error_rate_breakdown = error_handler(reference, hypothesis)
    except (ValueError, AttributeError, ZeroDivisionError) as err:
        print(f"{type(err).__name__}: {str(err)}")
        return None

    b = word_error_rate_breakdown

    # Unwrap 0-D container
    if isinstance(b, np.ndarray) and b.ndim == 0:
        b = b.item()

    if isinstance(b, np.ndarray):
        if b.ndim == 2:
            # True 2-D numeric batch
            t = b.T
            weighted_insertions = t[3] * insertions_weight
            weighted_deletions = t[4] * deletions_weight
            weighted_substitutions = t[5] * substitutions_weight
            m = t[2]
            weighted_errors = weighted_insertions + weighted_deletions + weighted_substitutions
            werps_result = (weighted_errors / m).tolist()

        elif b.ndim == 1:
            # Could be either:
            # (a) single example row vector, or
            # (b) object array of per-example vectors
            first = b[0] if b.size else None

            if isinstance(first, (np.ndarray, list, tuple)):
                # Batch stored as 1-D object array of per-example vectors (ragged fields exist)
                werps_result = []
                for r in b:
                    rr = r.tolist() if isinstance(r, np.ndarray) else r
                    w_ins = float(rr[3]) * insertions_weight
                    w_del = float(rr[4]) * deletions_weight
                    w_sub = float(rr[5]) * substitutions_weight
                    m_val = float(rr[2])
                    weighted_wer = (w_ins + w_del + w_sub) / m_val if m_val else 0.0
                    werps_result.append(weighted_wer)
            else:
                # Single example vector
                weighted_insertions = b[3] * insertions_weight
                weighted_deletions = b[4] * deletions_weight
                weighted_substitutions = b[5] * substitutions_weight
                m = b[2]
                weighted_errors = weighted_insertions + weighted_deletions + weighted_substitutions
                werps_result = float(weighted_errors / m) if m else 0.0

        else:
            raise ValueError(f"Unexpected metrics output ndim: {b.ndim}")

    else:
        # Non-numpy fallback (assume [wer, ld, m, ...])
        weighted_insertions = b[3] * insertions_weight
        weighted_deletions = b[4] * deletions_weight
        weighted_substitutions = b[5] * substitutions_weight
        m = b[2]
        weighted_errors = weighted_insertions + weighted_deletions + weighted_substitutions
        werps_result = float(weighted_errors / m) if m else 0.0

    return werps_result
